{"/home/travis/build/npmtest/node-npmtest-musicmetadata/test.js":"/* istanbul instrument in package npmtest_musicmetadata */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/lib.npmtest_musicmetadata.js":"/* istanbul instrument in package npmtest_musicmetadata */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_musicmetadata = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_musicmetadata = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-musicmetadata && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_musicmetadata */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_musicmetadata\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_musicmetadata.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_musicmetadata.rollup.js'] =\n            local.assetsDict['/assets.npmtest_musicmetadata.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_musicmetadata.__dirname + '/lib.npmtest_musicmetadata.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/node_modules/musicmetadata/lib/index.js":"'use strict'\nvar events = require('events')\nvar common = require('./common')\nvar strtok = require('strtok2')\nvar through = require('through')\nvar fs = require('fs')\n\nmodule.exports = function (stream, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  }\n\n  var emitter = new events.EventEmitter()\n\n  var fsize = function (cb) {\n    if (opts.fileSize) {\n      process.nextTick(function () {\n        cb(opts.fileSize)\n      })\n    } else if (stream.hasOwnProperty('path')) {\n      fs.stat(stream.path, function (err, stats) {\n        if (err) throw err\n        cb(stats.size)\n      })\n    } else if (stream.hasOwnProperty('fileSize')) {\n      stream.fileSize(cb)\n    } else if (opts.duration) {\n      emitter.emit(\n        'done',\n        new Error('for non file streams, specify the size of the stream with a fileSize option'))\n    }\n  }\n\n  // pipe to an internal stream so we aren't messing\n  // with the stream passed to us by our users\n  var istream = stream.pipe(through(null, null, {autoDestroy: false}))\n\n  var metadata = {\n    title: '',\n    artist: [],\n    albumartist: [],\n    album: '',\n    year: '',\n    track: { no: 0, of: 0 },\n    genre: [],\n    disk: { no: 0, of: 0 },\n    picture: [],\n    duration: 0\n  }\n\n  var aliased = {}\n\n  var hasReadData = false\n  istream.once('data', function (result) {\n    hasReadData = true\n    var parser = common.getParserForMediaType(headerTypes, result)\n    parser(istream, function (event, value) {\n      if (value === null) return\n      var alias = lookupAlias(event)\n      // emit original event & value\n      if (event !== alias) {\n        emitter.emit(event, value)\n      }\n      buildAliases(alias, event, value, aliased)\n    }, done, opts.hasOwnProperty('duration'), fsize)\n    // re-emitting the first data chunk so the\n    // parser picks the stream up from the start\n    istream.emit('data', result)\n  })\n\n  istream.on('end', function () {\n    if (!hasReadData) {\n      done(new Error('Could not read any data from this stream'))\n    }\n  })\n\n  istream.on('close', onClose)\n\n  function onClose () {\n    done(new Error('Unexpected end of stream'))\n  }\n\n  function done (exception) {\n    istream.removeListener('close', onClose)\n\n    // We only emit aliased events once the 'done' event has been raised,\n    // this is because an alias like 'artist' could have values split\n    // over many data chunks.\n    for (var _alias in aliased) {\n      if (aliased.hasOwnProperty(_alias)) {\n        var val\n        if (_alias === 'title' || _alias === 'album' ||\n          _alias === 'year' || _alias === 'duration') {\n          val = aliased[_alias][0]\n        } else {\n          val = aliased[_alias]\n        }\n\n        emitter.emit(_alias, val)\n\n        if (metadata.hasOwnProperty(_alias)) {\n          metadata[_alias] = val\n        }\n      }\n    }\n\n    if (callback) {\n      callback(exception, metadata)\n    }\n    return strtok.DONE\n  }\n\n  return emitter\n}\n\nfunction buildAliases (alias, event, value, aliased) {\n  // we need to do something special for these events\n  var cleaned\n  if (event === 'TRACKTOTAL' || event === 'DISCTOTAL') {\n    var evt\n    if (event === 'TRACKTOTAL') evt = 'track'\n    if (event === 'DISCTOTAL') evt = 'disk'\n\n    cleaned = parseInt(value, 10)\n    if (isNaN(cleaned)) cleaned = 0\n    if (!aliased.hasOwnProperty(evt)) {\n      aliased[evt] = { no: 0, of: cleaned }\n    } else {\n      aliased[evt].of = cleaned\n    }\n  }\n\n  // if the event has been aliased then we need to clean it before\n  // it is emitted to the user. e.g. genre (20) -> Electronic\n  if (alias) {\n    cleaned = value\n    if (alias === 'genre') cleaned = common.parseGenre(value)\n    if (alias === 'picture') cleaned = cleanupPicture(value)\n\n    if (alias === 'track' || alias === 'disk') {\n      cleaned = cleanupTrack(value)\n\n      if (aliased[alias]) {\n        aliased[alias].no = cleaned.no\n        return\n      } else {\n        aliased[alias] = cleaned\n        return\n      }\n    }\n\n    // if we haven't previously seen this tag then\n    // initialize it to an array, ready for values to be entered\n    if (!aliased.hasOwnProperty(alias)) {\n      aliased[alias] = []\n    }\n\n    if (cleaned.constructor === Array) {\n      aliased[alias] = cleaned\n    } else {\n      aliased[alias].push(cleaned)\n    }\n  }\n}\n\nfunction lookupAlias (event) {\n  // mappings for common metadata types(id3v2.3, id3v2.2, id4, vorbis, APEv2)\n  var mappings = [\n    ['title', 'TIT2', 'TT2', '©nam', 'TITLE', 'Title'],\n    ['artist', 'TPE1', 'TP1', '©ART', 'ARTIST', 'Author'],\n    ['albumartist', 'TPE2', 'TP2', 'aART', 'ALBUMARTIST', 'ENSEMBLE', 'WM/AlbumArtist'],\n    ['album', 'TALB', 'TAL', '©alb', 'ALBUM', 'WM/AlbumTitle'],\n    ['year', 'TDRC', 'TYER', 'TYE', '©day', 'DATE', 'Year', 'WM/Year'],\n    ['comment', 'COMM', 'COM', '©cmt', 'COMMENT'],\n    ['track', 'TRCK', 'TRK', 'trkn', 'TRACKNUMBER', 'Track', 'WM/TrackNumber'],\n    ['disk', 'TPOS', 'TPA', 'disk', 'DISCNUMBER', 'Disk'],\n    ['genre', 'TCON', 'TCO', '©gen', 'gnre', 'GENRE', 'WM/Genre'],\n    ['picture', 'APIC', 'PIC', 'covr', 'METADATA_BLOCK_PICTURE', 'Cover Art (Front)',\n    'Cover Art (Back)'],\n    ['composer', 'TCOM', 'TCM', '©wrt', 'COMPOSER'],\n    ['duration'],\n    ['lyrics', 'SYLT']\n  ]\n\n  return mappings.reduce(function (a, b) {\n    if (a !== undefined) return a\n\n    var hasAlias = b.map(function (val) {\n      return val.toUpperCase()\n    }).indexOf(event.toUpperCase())\n\n    if (hasAlias > -1) {\n      return b[0]\n    }\n  }, undefined)\n}\n\n// TODO: a string of 1of1 would fail to be converted\n// converts 1/10 to no : 1, of : 10\n// or 1 to no : 1, of : 0\nfunction cleanupTrack (origVal) {\n  var split = origVal.toString().split('/')\n  return {\n    no: parseInt(split[0], 10) || 0,\n    of: parseInt(split[1], 10) || 0\n  }\n}\n\nfunction cleanupPicture (picture) {\n  var newFormat\n  if (picture.format) {\n    var split = picture.format.toLowerCase().split('/')\n    newFormat = (split.length > 1) ? split[1] : split[0]\n    if (newFormat === 'jpeg') newFormat = 'jpg'\n  } else {\n    newFormat = 'jpg'\n  }\n  return { format: newFormat, data: picture.data }\n}\n\nvar headerTypes = [\n  {\n    buf: common.asfGuidBuf,\n    tag: require('./asf')\n  },\n  {\n    buf: new Buffer('ID3'),\n    tag: require('./id3v2')\n  },\n  {\n    buf: new Buffer('ftypM4A'),\n    tag: require('./id4'),\n    offset: 4\n  },\n  {\n    buf: new Buffer('ftypmp42'),\n    tag: require('./id4'),\n    offset: 4\n  },\n  {\n    buf: new Buffer('OggS'),\n    tag: require('./ogg')\n  },\n  {\n    buf: new Buffer('fLaC'),\n    tag: require('./flac')\n  },\n  {\n    buf: new Buffer('MAC'),\n    tag: require('./monkeysaudio')\n  }\n]\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/node_modules/musicmetadata/lib/common.js":"'use strict'\nvar strtok = require('strtok2')\nvar equal = require('deep-equal')\nvar windows1252decoder = require('./windows1252decoder')\n\nvar asfGuidBuf = new Buffer([\n  0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11,\n  0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C\n])\nexports.asfGuidBuf = asfGuidBuf\n\nexports.getParserForMediaType = function (types, header) {\n  for (var i = 0; i < types.length; i += 1) {\n    var type = types[i]\n    var offset = type.offset || 0\n    if (header.length >= offset + type.buf.length &&\n      equal(header.slice(offset, offset + type.buf.length), type.buf)) {\n      return type.tag\n    }\n  }\n  // default to id3v1.1 if we cannot detect any other tags\n  return require('./id3v1')\n}\n\nexports.streamOnRealEnd = function (stream, callback) {\n  stream.on('end', done)\n  stream.on('close', done)\n  function done () {\n    stream.removeListener('end', done)\n    stream.removeListener('close', done)\n    callback()\n  }\n}\n\nexports.readVorbisPicture = function (buffer) {\n  var picture = {}\n  var offset = 0\n\n  picture.type = PICTURE_TYPE[strtok.UINT32_BE.get(buffer, 0)]\n\n  var mimeLen = strtok.UINT32_BE.get(buffer, offset += 4)\n  picture.format = buffer.toString('utf-8', offset += 4, offset + mimeLen)\n\n  var descLen = strtok.UINT32_BE.get(buffer, offset += mimeLen)\n  picture.description = buffer.toString('utf-8', offset += 4, offset + descLen)\n\n  picture.width = strtok.UINT32_BE.get(buffer, offset += descLen)\n  picture.height = strtok.UINT32_BE.get(buffer, offset += 4)\n  picture.colour_depth = strtok.UINT32_BE.get(buffer, offset += 4)\n  picture.indexed_color = strtok.UINT32_BE.get(buffer, offset += 4)\n\n  var picDataLen = strtok.UINT32_BE.get(buffer, offset += 4)\n  picture.data = new Buffer(buffer.slice(offset += 4, offset + picDataLen))\n\n  return picture\n}\n\nexports.removeUnsyncBytes = function (buffer) {\n  var readI = 0\n  var writeI = 0\n  while (readI < buffer.length - 1) {\n    if (readI !== writeI) {\n      buffer[writeI] = buffer[readI]\n    }\n    readI += (buffer[readI] === 0xFF && buffer[readI + 1] === 0) ? 2 : 1\n    writeI++\n  }\n  if (readI < buffer.length) {\n    buffer[writeI++] = buffer[readI++]\n  }\n  return buffer.slice(0, writeI)\n}\n\nexports.findZero = function (buffer, start, end, encoding) {\n  var i = start\n  if (encoding === 'utf16') {\n    while (buffer[i] !== 0 || buffer[i + 1] !== 0) {\n      if (i >= end) return end\n      i += 2\n    }\n    return i\n  } else {\n    while (buffer[i] !== 0) {\n      if (i >= end) return end\n      i++\n    }\n    return i\n  }\n}\n\nexports.sum = function (arr) {\n  var s = 0\n  var i\n  for (i = 0; i < arr.length; i++) {\n    s += arr[i]\n  }\n  return s\n}\n\nfunction swapBytes (buffer) {\n  var l = buffer.length\n  if (l & 0x01) {\n    throw new Error('Buffer length must be even')\n  }\n  for (var i = 0; i < l; i += 2) {\n    var a = buffer[i]\n    buffer[i] = buffer[i + 1]\n    buffer[i + 1] = a\n  }\n  return buffer\n}\n\nvar readUTF16String = exports.readUTF16String = function (buffer) {\n  var offset = 0\n  if (buffer[0] === 0xFE && buffer[1] === 0xFF) { // big endian\n    buffer = swapBytes(buffer)\n    offset = 2\n  } else if (buffer[0] === 0xFF && buffer[1] === 0xFE) { // little endian\n    offset = 2\n  }\n  return buffer.toString('ucs2', offset)\n}\n\nexports.decodeString = function (buffer, encoding) {\n  // annoying workaround for a double BOM issue\n  // https://github.com/leetreveil/musicmetadata/issues/84\n  if (buffer[0] === 0xFF && buffer[1] === 0xFE && buffer[2] === 0xFE && buffer[3] === 0xFF) {\n    buffer = buffer.slice(2)\n  }\n\n  if (encoding === 'utf16le' || encoding === 'utf16') {\n    return readUTF16String(buffer)\n  } else if (encoding === 'utf8') {\n    return buffer.toString('utf8')\n  } else if (encoding === 'iso-8859-1') {\n    return windows1252decoder(buffer)\n  }\n\n  throw Error(encoding + ' encoding is not supported!')\n}\n\nexports.parseGenre = function (origVal) {\n  // match everything inside parentheses\n  var split = origVal.trim().split(/\\((.*?)\\)/g)\n    .filter(function (val) { return val !== '' })\n\n  var array = []\n  for (var i = 0; i < split.length; i++) {\n    var cur = split[i]\n    if (/^\\d+$/.test(cur) && !isNaN(parseInt(cur, 10))) {\n      cur = GENRES[cur]\n    }\n    array.push(cur)\n  }\n\n  return array\n    .filter(function (val) { return val !== undefined })\n    .join('/')\n}\n\nexports.stripNulls = function (str) {\n  str = str.replace(/^\\x00+/g, '')\n  str = str.replace(/\\x00+$/g, '')\n  return str\n}\n\nexports.strtokUINT24_BE = {\n  len: 3,\n  get: function (buf, off) {\n    return (((buf[off] << 8) + buf[off + 1]) << 8) + buf[off + 2]\n  }\n}\n\nexports.strtokBITSET = {\n  len: 1,\n  get: function (buf, off, bit) {\n    return (buf[off] & (1 << bit)) !== 0\n  }\n}\n\nexports.strtokINT32SYNCSAFE = {\n  len: 4,\n  get: function (buf, off) {\n    return buf[off + 3] & 0x7f | ((buf[off + 2]) << 7) |\n        ((buf[off + 1]) << 14) | ((buf[off]) << 21)\n  }\n}\n\nvar PICTURE_TYPE = exports.PICTURE_TYPE = [\n  'Other',\n  \"32x32 pixels 'file icon' (PNG only)\",\n  'Other file icon',\n  'Cover (front)',\n  'Cover (back)',\n  'Leaflet page',\n  'Media (e.g. lable side of CD)',\n  'Lead artist/lead performer/soloist',\n  'Artist/performer',\n  'Conductor',\n  'Band/Orchestra',\n  'Composer',\n  'Lyricist/text writer',\n  'Recording Location',\n  'During recording',\n  'During performance',\n  'Movie/video screen capture',\n  'A bright coloured fish',\n  'Illustration',\n  'Band/artist logotype',\n  'Publisher/Studio logotype'\n]\n\nvar GENRES = exports.GENRES = [\n  'Blues', 'Classic Rock', 'Country', 'Dance', 'Disco', 'Funk', 'Grunge', 'Hip-Hop',\n  'Jazz', 'Metal', 'New Age', 'Oldies', 'Other', 'Pop', 'R&B', 'Rap', 'Reggae', 'Rock',\n  'Techno', 'Industrial', 'Alternative', 'Ska', 'Death Metal', 'Pranks', 'Soundtrack',\n  'Euro-Techno', 'Ambient', 'Trip-Hop', 'Vocal', 'Jazz+Funk', 'Fusion', 'Trance',\n  'Classical', 'Instrumental', 'Acid', 'House', 'Game', 'Sound Clip', 'Gospel', 'Noise',\n  'Alt. Rock', 'Bass', 'Soul', 'Punk', 'Space', 'Meditative', 'Instrumental Pop',\n  'Instrumental Rock', 'Ethnic', 'Gothic', 'Darkwave', 'Techno-Industrial',\n  'Electronic', 'Pop-Folk', 'Eurodance', 'Dream', 'Southern Rock', 'Comedy', 'Cult',\n  'Gangsta Rap', 'Top 40', 'Christian Rap', 'Pop/Funk', 'Jungle', 'Native American',\n  'Cabaret', 'New Wave', 'Psychedelic', 'Rave', 'Showtunes', 'Trailer', 'Lo-Fi', 'Tribal',\n  'Acid Punk', 'Acid Jazz', 'Polka', 'Retro', 'Musical', 'Rock & Roll', 'Hard Rock',\n  'Folk', 'Folk/Rock', 'National Folk', 'Swing', 'Fast-Fusion', 'Bebob', 'Latin', 'Revival',\n  'Celtic', 'Bluegrass', 'Avantgarde', 'Gothic Rock', 'Progressive Rock', 'Psychedelic Rock',\n  'Symphonic Rock', 'Slow Rock', 'Big Band', 'Chorus', 'Easy Listening', 'Acoustic', 'Humour',\n  'Speech', 'Chanson', 'Opera', 'Chamber Music', 'Sonata', 'Symphony', 'Booty Bass', 'Primus',\n  'Porn Groove', 'Satire', 'Slow Jam', 'Club', 'Tango', 'Samba', 'Folklore',\n  'Ballad', 'Power Ballad', 'Rhythmic Soul', 'Freestyle', 'Duet', 'Punk Rock', 'Drum Solo',\n  'A Cappella', 'Euro-House', 'Dance Hall', 'Goa', 'Drum & Bass', 'Club-House',\n  'Hardcore', 'Terror', 'Indie', 'BritPop', 'Negerpunk', 'Polsk Punk', 'Beat',\n  'Christian Gangsta Rap', 'Heavy Metal', 'Black Metal', 'Crossover', 'Contemporary Christian',\n  'Christian Rock', 'Merengue', 'Salsa', 'Thrash Metal', 'Anime', 'JPop', 'Synthpop',\n  'Abstract', 'Art Rock', 'Baroque', 'Bhangra', 'Big Beat', 'Breakbeat', 'Chillout',\n  'Downtempo', 'Dub', 'EBM', 'Eclectic', 'Electro', 'Electroclash', 'Emo', 'Experimental',\n  'Garage', 'Global', 'IDM', 'Illbient', 'Industro-Goth', 'Jam Band', 'Krautrock',\n  'Leftfield', 'Lounge', 'Math Rock', 'New Romantic', 'Nu-Breakz', 'Post-Punk', 'Post-Rock',\n  'Psytrance', 'Shoegaze', 'Space Rock', 'Trop Rock', 'World Music', 'Neoclassical', 'Audiobook',\n  'Audio Theatre', 'Neue Deutsche Welle', 'Podcast', 'Indie Rock', 'G-Funk', 'Dubstep',\n  'Garage Rock', 'Psybient'\n]\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/node_modules/musicmetadata/lib/windows1252decoder.js":"var windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352,\n8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732,\n8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168,\n169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,\n185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200,\n201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,\n217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,\n233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,\n248, 249, 250, 251, 252, 253, 254, 255]\n\nfunction inRange (a, min, max) {\n  return min <= a && a <= max\n}\n\nfunction codePointToString (cp) {\n  if (cp <= 0xFFFF) {\n    return String.fromCharCode(cp)\n  } else {\n    cp -= 0x10000\n    return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00)\n  }\n}\n\nfunction singleByteDecoder (bite, index) {\n  if (inRange(bite, 0x00, 0x7F)) {\n    return bite\n  }\n\n  var code_point = index[bite - 0x80]\n  if (code_point === null) {\n    throw Error('invaliding encoding')\n  }\n\n  return code_point\n}\n\nmodule.exports = function (buffer) {\n  var str = ''\n  for (var i = 0; i < buffer.length; i++) {\n    str += codePointToString(singleByteDecoder(buffer[i], windows1252))\n  }\n  return str\n}\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/node_modules/musicmetadata/lib/asf.js":"'use strict'\nvar strtok = require('strtok2')\nvar common = require('./common')\nvar equal = require('deep-equal')\n\nvar decodeString = common.decodeString\n\nmodule.exports = function (stream, callback, done) {\n  var currentState = startState\n\n  strtok.parse(stream, function (v, cb) {\n    currentState = currentState.parse(callback, v, done)\n    return currentState.getExpectedType()\n  })\n}\n\nvar startState = {\n  parse: function (callback) {\n    return idState\n  }\n}\n\nvar finishedState = {\n  parse: function (callback) {\n    return this\n  },\n  getExpectedType: function () {\n    return strtok.DONE\n  }\n}\n\nvar idState = {\n  parse: function (callback, data, done) {\n    if (!equal(common.asfGuidBuf, data)) {\n      done(new Error('expected asf header but was not found'))\n      return finishedState\n    }\n    return headerDataState\n  },\n  getExpectedType: function () {\n    return new strtok.BufferType(common.asfGuidBuf.length)\n  }\n}\n\nfunction ReadObjectState (size, objectCount) {\n  this.size = size\n  this.objectCount = objectCount\n}\n\nReadObjectState.prototype.parse = function (callback, data, done) {\n  var guid = data.slice(0, 16)\n  var size = readUInt64LE(data, 16)\n  var State = stateByGuid(guid) || IgnoreObjectState\n  this.objectCount -= 1\n  this.size -= size\n  var nextState = (this.objectCount <= 0) ? finishedState : this\n  return new State(nextState, size - 24)\n}\n\nReadObjectState.prototype.getExpectedType = function () {\n  return new strtok.BufferType(24)\n}\n\nvar headerDataState = {\n  parse: function (callback, data, done) {\n    var size = readUInt64LE(data, 0)\n    var objectCount = data.readUInt32LE(8)\n    return new ReadObjectState(size, objectCount)\n  },\n  getExpectedType: function () {\n    // 8 bytes size\n    // 4 bytes object count\n    // 2 bytes ignore\n    return new strtok.BufferType(14)\n  }\n}\n\nfunction IgnoreObjectState (nextState, size) {\n  this.nextState = nextState\n  this.size = size\n}\n\nIgnoreObjectState.prototype.parse = function (callback, data, done) {\n  if (this.nextState === finishedState) done()\n  return this.nextState\n}\n\nIgnoreObjectState.prototype.getExpectedType = function () {\n  return new strtok.IgnoreType(this.size)\n}\n\nfunction ContentDescriptionObjectState (nextState, size) {\n  this.nextState = nextState\n  this.size = size\n}\n\nvar contentDescTags = ['Title', 'Author', 'Copyright', 'Description', 'Rating']\nContentDescriptionObjectState.prototype.parse = function (callback, data, done) {\n  var lengths = [\n    data.readUInt16LE(0),\n    data.readUInt16LE(2),\n    data.readUInt16LE(4),\n    data.readUInt16LE(6),\n    data.readUInt16LE(8)\n  ]\n  var pos = 10\n  for (var i = 0; i < contentDescTags.length; i += 1) {\n    var tagName = contentDescTags[i]\n    var length = lengths[i]\n    var end = pos + length\n    if (length > 0) {\n      var value = parseUnicodeAttr(data.slice(pos, end))\n      callback(tagName, value)\n    }\n    pos = end\n  }\n  if (this.nextState === finishedState) done()\n  return this.nextState\n}\n\nContentDescriptionObjectState.prototype.getExpectedType = function () {\n  return new strtok.BufferType(this.size)\n}\n\nContentDescriptionObjectState.guid = new Buffer([\n  0x33, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11,\n  0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C\n])\n\nfunction ExtendedContentDescriptionObjectState (nextState, size) {\n  this.nextState = nextState\n  this.size = size\n}\n\nvar attributeParsers = [\n  parseUnicodeAttr,\n  parseByteArrayAttr,\n  parseBoolAttr,\n  parseDWordAttr,\n  parseQWordAttr,\n  parseWordAttr,\n  parseByteArrayAttr\n]\n\nExtendedContentDescriptionObjectState.prototype.parse = function (callback, data, done) {\n  var attrCount = data.readUInt16LE(0)\n  var pos = 2\n  for (var i = 0; i < attrCount; i += 1) {\n    var nameLen = data.readUInt16LE(pos)\n    pos += 2\n    var name = parseUnicodeAttr(data.slice(pos, pos + nameLen))\n    pos += nameLen\n    var valueType = data.readUInt16LE(pos)\n    pos += 2\n    var valueLen = data.readUInt16LE(pos)\n    pos += 2\n    var value = data.slice(pos, pos + valueLen)\n    pos += valueLen\n    var parseAttr = attributeParsers[valueType]\n    if (!parseAttr) {\n      done(new Error('unexpected value type: ' + valueType))\n      return finishedState\n    }\n    var attr = parseAttr(value)\n    callback(name, attr)\n  }\n  if (this.nextState === finishedState) done()\n  return this.nextState\n}\n\nExtendedContentDescriptionObjectState.prototype.getExpectedType = function () {\n  return new strtok.BufferType(this.size)\n}\n\nExtendedContentDescriptionObjectState.guid = new Buffer([\n  0x40, 0xA4, 0xD0, 0xD2, 0x07, 0xE3, 0xD2, 0x11,\n  0x97, 0xF0, 0x00, 0xA0, 0xC9, 0x5E, 0xA8, 0x50\n])\n\nfunction FilePropertiesObject (nextState, size) {\n  this.nextState = nextState\n  this.size = size\n}\n\nFilePropertiesObject.prototype.parse = function (callback, data, done) {\n  // in miliseconds\n  var playDuration = parseQWordAttr(data.slice(40, 48)) / 10000\n  callback('duration', playDuration / 1000)\n\n  if (this.nextState === finishedState) done()\n  return this.nextState\n}\n\nFilePropertiesObject.prototype.getExpectedType = function () {\n  return new strtok.BufferType(this.size)\n}\n\nFilePropertiesObject.guid = new Buffer([\n  0xA1, 0xDC, 0xAB, 0x8C, 0x47, 0xA9, 0xCF, 0x11,\n  0x8E, 0xE4, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65\n])\n\nvar guidStates = [\n  FilePropertiesObject,\n  ContentDescriptionObjectState,\n  ExtendedContentDescriptionObjectState\n]\nfunction stateByGuid (guidBuf) {\n  for (var i = 0; i < guidStates.length; i += 1) {\n    var GuidState = guidStates[i]\n    if (equal(GuidState.guid, guidBuf)) return GuidState\n  }\n  return null\n}\n\nfunction parseUnicodeAttr (buf) {\n  return common.stripNulls(decodeString(buf, 'utf16le'))\n}\n\nfunction parseByteArrayAttr (buf) {\n  var newBuf = new Buffer(buf.length)\n  buf.copy(newBuf)\n  return newBuf\n}\n\nfunction parseBoolAttr (buf) {\n  return parseDWordAttr(buf) === 1\n}\n\nfunction parseDWordAttr (buf) {\n  return buf.readUInt32LE(0)\n}\n\nfunction parseQWordAttr (buf) {\n  return readUInt64LE(buf, 0)\n}\n\nfunction parseWordAttr (buf) {\n  return buf.readUInt16LE(0)\n}\n\nfunction readUInt64LE (buffer, offset) {\n  var high = buffer.slice(offset, offset + 4).readUInt32LE(0)\n  var low = buffer.slice(offset + 4, offset + 8).readUInt32LE(0)\n  var maxuint32 = Math.pow(2, 32)\n  return ((low * maxuint32) + (high >>> 0))\n}\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/node_modules/musicmetadata/lib/id3v2.js":"'use strict'\nvar strtok = require('strtok2')\nvar parser = require('./id3v2_frames')\nvar common = require('./common')\n\nmodule.exports = function (stream, callback, done, readDuration, fileSize) {\n  var frameCount = 0\n  var audioFrameHeader\n  var bitrates = []\n\n  strtok.parse(stream, function (v, cb) {\n    if (v === undefined) {\n      cb.state = 0\n      return new strtok.BufferType(10)\n    }\n\n    switch (cb.state) {\n      case 0: // header\n        if (v.toString('ascii', 0, 3) !== 'ID3') {\n          return done(new Error('expected id3 header but was not found'))\n        }\n        cb.id3Header = {\n          version: '2.' + v[3] + '.' + v[4],\n          major: v[3],\n          unsync: common.strtokBITSET.get(v, 5, 7),\n          xheader: common.strtokBITSET.get(v, 5, 6),\n          xindicator: common.strtokBITSET.get(v, 5, 5),\n          footer: common.strtokBITSET.get(v, 5, 4),\n          size: common.strtokINT32SYNCSAFE.get(v, 6)\n        }\n        cb.state = 1\n        return new strtok.BufferType(cb.id3Header.size)\n\n      case 1: // id3 data\n        parseMetadata(v, cb.id3Header, done).map(function (obj) {\n          callback.apply(this, obj)\n        })\n        if (readDuration) {\n          cb.state = 2\n          return new strtok.BufferType(4)\n        }\n        return done()\n\n      case 1.5:\n        var shiftedBuffer = new Buffer(4)\n        cb.frameFragment.copy(shiftedBuffer, 0, 1)\n        v.copy(shiftedBuffer, 3)\n        v = shiftedBuffer\n        cb.state = 2\n\n      /* falls through */\n      case 2: // audio frame header\n\n        // we have found the id3 tag at the end of the file, ignore\n        if (v.slice(0, 3).toString() === 'TAG') {\n          return done()\n        }\n\n        // first 11 bits should all be set (frame sync)\n        if ((v[0] === 0xFF && (v[1] & 0xE0) === 0xE0) !== true) {\n          // keep scanning for frame header, id3 tag may\n          // have some padding (0x00) at the end\n          return seekFirstAudioFrame(done)\n        }\n\n        var header = {\n          'version': readMpegVersion(v[1]),\n          'layer': readLayer(v[1]),\n          'protection': !(v[1] & 0x1),\n          'padding': !!((v[2] & 0x02) >> 1),\n          'mode': readMode(v[3])\n        }\n\n        if (isNaN(header.version) || isNaN(header.layer)) {\n          return seekFirstAudioFrame(done)\n        }\n\n        // mp3 files are only found in MPEG1/2 Layer 3\n        if ((header.version !== 1 && header.version !== 2) || header.layer !== 3) {\n          return seekFirstAudioFrame(done)\n        }\n\n        header.samples_per_frame = calcSamplesPerFrame(\n          header.version, header.layer)\n\n        header.bitrate = id3BitrateCalculator(v[2], header.version, header.layer)\n        if (isNaN(header.bitrate)) {\n          return seekFirstAudioFrame(done)\n        }\n\n        header.sample_rate = samplingRateCalculator(v[2], header.version)\n        if (isNaN(header.sample_rate)) {\n          return seekFirstAudioFrame(done)\n        }\n\n        header.slot_size = calcSlotSize(header.layer)\n\n        header.sideinfo_length = calculateSideInfoLength(\n          header.layer, header.mode, header.version)\n\n        var bps = header.samples_per_frame / 8.0\n        var fsize = (bps * (header.bitrate * 1000) / header.sample_rate) +\n          ((header.padding) ? header.slot_size : 0)\n        header.frame_size = Math.floor(fsize)\n\n        audioFrameHeader = header\n        frameCount++\n        bitrates.push(header.bitrate)\n\n        // xtra header only exists in first frame\n        if (frameCount === 1) {\n          cb.offset = header.sideinfo_length\n          cb.state = 3\n          return new strtok.BufferType(header.sideinfo_length)\n        }\n\n        // the stream is CBR if the first 3 frame bitrates are the same\n        if (readDuration && fileSize && frameCount === 3 && areAllSame(bitrates)) {\n          fileSize(function (size) {\n            // subtract non audio stream data from duration calculation\n            size = size - cb.id3Header.size\n            var kbps = (header.bitrate * 1000) / 8\n            callback('duration', size / kbps)\n            cb(done())\n          })\n          return strtok.DEFER\n        }\n\n        // once we know the file is VBR attach listener to end of\n        // stream so we can do the duration calculation when we\n        // have counted all the frames\n        if (readDuration && frameCount === 4) {\n          stream.once('end', function () {\n            callback('duration', calcDuration(frameCount,\n              header.samples_per_frame, header.sample_rate))\n            done()\n          })\n        }\n\n        cb.state = 5\n        return new strtok.IgnoreType(header.frame_size - 4)\n\n      case 3: // side information\n        cb.offset += 12\n        cb.state = 4\n        return new strtok.BufferType(12)\n\n      case 4: // xtra / info header\n        cb.state = 5\n        var frameDataLeft = audioFrameHeader.frame_size - 4 - cb.offset\n\n        var id = v.toString('ascii', 0, 4)\n        if (id !== 'Xtra' && id !== 'Info' && id !== 'Xing') {\n          return new strtok.IgnoreType(frameDataLeft)\n        }\n\n        // frames field is not present\n        if ((v[7] & 0x01) !== 1) {\n          return new strtok.IgnoreType(frameDataLeft)\n        }\n\n        var numFrames = v.readUInt32BE(8)\n        var ah = audioFrameHeader\n        callback('duration', calcDuration(numFrames, ah.samples_per_frame, ah.sample_rate))\n        return done()\n\n      case 5: // skip frame data\n        cb.state = 2\n        return new strtok.BufferType(4)\n    }\n\n    function seekFirstAudioFrame (done) {\n      if (frameCount) {\n        return done(new Error('expected frame header but was not found'))\n      }\n\n      cb.frameFragment = v\n      cb.state = 1.5\n      return new strtok.BufferType(1)\n    }\n  })\n}\n\nfunction areAllSame (array) {\n  var first = array[0]\n  return array.every(function (element) {\n    return element === first\n  })\n}\n\nfunction calcDuration (numFrames, samplesPerFrame, sampleRate) {\n  return Math.round(numFrames * (samplesPerFrame / sampleRate))\n}\n\nfunction parseMetadata (data, header, done) {\n  var offset = 0\n  var frames = []\n\n  if (header.xheader) {\n    offset += data.readUInt32BE(0)\n  }\n\n  while (true) {\n    if (offset === data.length) break\n    var frameHeaderBytes = data.slice(offset, offset += getFrameHeaderLength(header.major, done))\n    var frameHeader = readFrameHeader(frameHeaderBytes, header.major)\n\n    // Last frame. Check first char is a letter, bit of defensive programming\n    if (frameHeader.id === '' || frameHeader.id === '\\u0000\\u0000\\u0000\\u0000' ||\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(frameHeader.id[0]) === -1) {\n      break\n    }\n\n    var frameDataBytes = data.slice(offset, offset += frameHeader.length)\n    var frameData = readFrameData(frameDataBytes, frameHeader, header.major)\n    for (var pos in frameData) {\n      if (frameData.hasOwnProperty(pos)) {\n        frames.push([frameHeader.id, frameData[pos]])\n      }\n    }\n  }\n  return frames\n}\n\nfunction readFrameData (v, frameHeader, majorVer) {\n  switch (majorVer) {\n    case 2:\n      return parser.readData(v, frameHeader.id, null, majorVer)\n    case 3:\n    case 4:\n      if (frameHeader.flags.format.unsync) {\n        v = common.removeUnsyncBytes(v)\n      }\n      if (frameHeader.flags.format.data_length_indicator) {\n        v = v.slice(4, v.length)\n      }\n      return parser.readData(v, frameHeader.id, frameHeader.flags, majorVer)\n  }\n}\n\nfunction readFrameHeader (v, majorVer) {\n  var header = {}\n  switch (majorVer) {\n    case 2:\n      header.id = v.toString('ascii', 0, 3)\n      header.length = common.strtokUINT24_BE.get(v, 3, 6)\n    break\n    case 3:\n      header.id = v.toString('ascii', 0, 4)\n      header.length = strtok.UINT32_BE.get(v, 4, 8)\n      header.flags = readFrameFlags(v.slice(8, 10))\n    break\n    case 4:\n      header.id = v.toString('ascii', 0, 4)\n      header.length = common.strtokINT32SYNCSAFE.get(v, 4, 8)\n      header.flags = readFrameFlags(v.slice(8, 10))\n    break\n  }\n  return header\n}\n\nfunction getFrameHeaderLength (majorVer, done) {\n  switch (majorVer) {\n    case 2:\n      return 6\n    case 3:\n    case 4:\n      return 10\n    default:\n      return done(new Error('header version is incorrect'))\n  }\n}\n\nfunction readFrameFlags (b) {\n  return {\n    status: {\n      tag_alter_preservation: common.strtokBITSET.get(b, 0, 6),\n      file_alter_preservation: common.strtokBITSET.get(b, 0, 5),\n      read_only: common.strtokBITSET.get(b, 0, 4)\n    },\n    format: {\n      grouping_identity: common.strtokBITSET.get(b, 1, 7),\n      compression: common.strtokBITSET.get(b, 1, 3),\n      encryption: common.strtokBITSET.get(b, 1, 2),\n      unsync: common.strtokBITSET.get(b, 1, 1),\n      data_length_indicator: common.strtokBITSET.get(b, 1, 0)\n    }\n  }\n}\n\nfunction readMpegVersion (byte) {\n  var bits = (byte & 0x18) >> 3\n\n  if (bits === 0x00) {\n    return 2.5\n  } else if (bits === 0x01) {\n    return 'reserved'\n  } else if (bits === 0x02) {\n    return 2\n  } else if (bits === 0x03) {\n    return 1\n  }\n}\n\nfunction readLayer (byte) {\n  var bits = (byte & 0x6) >> 1\n\n  if (bits === 0x00) {\n    return 'reserved'\n  } else if (bits === 0x01) {\n    return 3\n  } else if (bits === 0x02) {\n    return 2\n  } else if (bits === 0x03) {\n    return 1\n  }\n}\n\nfunction readMode (byte) {\n  var bits = (byte & 0xC0) >> 6\n  if (bits === 0x00) {\n    return 'stereo'\n  } else if (bits === 0x01) {\n    return 'joint_stereo'\n  } else if (bits === 0x02) {\n    return 'dual_channel'\n  } else if (bits === 0x03) {\n    return 'mono'\n  }\n}\n\nfunction calcSamplesPerFrame (version, layer) {\n  if (layer === 1) return 384\n  if (layer === 2) return 1152\n  if (layer === 3 && version === 1) return 1152\n  if (layer === 3 && (version === 2 || version === 2.5)) return 576\n}\n\nfunction calculateSideInfoLength (layer, mode, version) {\n  if (layer !== 3) return 2\n  if (['stereo', 'joint_stereo', 'dual_channel'].indexOf(mode) >= 0) {\n    if (version === 1) {\n      return 32\n    } else if (version === 2 || version === 2.5) {\n      return 17\n    }\n  } else if (mode === 'mono') {\n    if (version === 1) {\n      return 17\n    } else if (version === 2 || version === 2.5) {\n      return 9\n    }\n  }\n}\n\nfunction calcSlotSize (layer) {\n  if (layer === 0) return 'reserved'\n  if (layer === 1) return 4\n  if (layer === 2) return 1\n  if (layer === 3) return 1\n}\n\n// [bits][mpegversion + layer] = bitrate\nvar bitrate_index = {\n    0x01: {'11': 32, '12': 32, '13': 32, '21': 32, '22': 8, '23': 8},\n    0x02: {'11': 64, '12': 48, '13': 40, '21': 48, '22': 16, '23': 16},\n    0x03: {'11': 96, '12': 56, '13': 48, '21': 56, '22': 24, '23': 24},\n    0x04: {'11': 128, '12': 64, '13': 56, '21': 64, '22': 32, '23': 32},\n    0x05: {'11': 160, '12': 80, '13': 64, '21': 80, '22': 40, '23': 40},\n    0x06: {'11': 192, '12': 96, '13': 80, '21': 96, '22': 48, '23': 48},\n    0x07: {'11': 224, '12': 112, '13': 96, '21': 112, '22': 56, '23': 56},\n    0x08: {'11': 256, '12': 128, '13': 112, '21': 128, '22': 64, '23': 64},\n    0x09: {'11': 288, '12': 160, '13': 128, '21': 144, '22': 80, '23': 80},\n    0x0A: {'11': 320, '12': 192, '13': 160, '21': 160, '22': 96, '23': 96},\n    0x0B: {'11': 352, '12': 224, '13': 192, '21': 176, '22': 112, '23': 112},\n    0x0C: {'11': 384, '12': 256, '13': 224, '21': 192, '22': 128, '23': 128},\n    0x0D: {'11': 416, '12': 320, '13': 256, '21': 224, '22': 144, '23': 144},\n    0x0E: {'11': 448, '12': 384, '13': 320, '21': 256, '22': 160, '23': 160}\n  }\n\nfunction id3BitrateCalculator (byte, mpegVersion, layer) {\n  var bits = (byte & 0xF0) >> 4\n  if (bits === 0x00) return 'free'\n  if (bits === 0x0F) return 'reserved'\n  return bitrate_index[bits][mpegVersion.toString() + layer]\n}\n\n// [version][bits] == sampling rate\nvar sampling_rate_freq_index = {\n    1: {0x00: 44100, 0x01: 48000, 0x02: 32000},\n    2: {0x00: 22050, 0x01: 24000, 0x02: 16000},\n    2.5: {0x00: 11025, 0x01: 12000, 0x02: 8000}\n}\n\nfunction samplingRateCalculator (byte, version) {\n  var bits = (byte & 0xC) >> 2\n  if (bits === 0x03) return 'reserved'\n  return sampling_rate_freq_index[version][bits]\n}\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/node_modules/musicmetadata/lib/id3v2_frames.js":"'use strict'\nvar Buffer = require('buffer').Buffer\nvar strtok = require('strtok2')\nvar common = require('./common')\nvar findZero = common.findZero\nvar decodeString = common.decodeString\n\nexports.readData = function readData (b, type, flags, major) {\n  var encoding = getTextEncoding(b[0])\n  var length = b.length\n  var offset = 0\n  var output = []\n  var nullTerminatorLength = getNullTerminatorLength(encoding)\n  var fzero\n\n  if (type[0] === 'T') {\n    type = 'T*'\n  }\n\n  switch (type) {\n    case 'T*':\n      var text = decodeString(b.slice(1), encoding).replace(/\\x00+$/, '')\n      // id3v2.4 defines that multiple T* values are separated by 0x00\n      output = text.split(/\\x00/g)\n      break\n\n    case 'PIC':\n    case 'APIC':\n      var pic = {}\n\n      offset += 1\n\n      switch (major) {\n        case 2:\n          pic.format = decodeString(b.slice(offset, offset + 3), encoding)\n          offset += 3\n          break\n        case 3:\n        case 4:\n          var enc = 'iso-8859-1'\n          fzero = findZero(b, offset, length, enc)\n          pic.format = decodeString(b.slice(offset, fzero), enc)\n          offset = fzero + 1\n          break\n      }\n\n      pic.type = common.PICTURE_TYPE[b[offset]]\n      offset += 1\n\n      fzero = findZero(b, offset, length, encoding)\n      pic.description = decodeString(b.slice(offset, fzero), encoding)\n      offset = fzero + nullTerminatorLength\n\n      pic.data = new Buffer(b.slice(offset, length))\n      output = [pic]\n      break\n\n    case 'CNT':\n    case 'PCNT':\n      output = [strtok.UINT32_BE.get(b, 0)]\n      break\n\n    case 'SYLT':\n      // skip text encoding (1 byte),\n      //      language (3 bytes),\n      //      time stamp format (1 byte),\n      //      content type (1 byte),\n      //      content descriptor (1 byte)\n      offset += 7\n\n      output = []\n      while (offset < length) {\n        var txt = b.slice(offset, offset = findZero(b, offset, length, encoding))\n        offset += 5 // push offset forward one +  4 byte timestamp\n        output.push(decodeString(txt, encoding))\n      }\n      break\n\n    case 'ULT':\n    case 'USLT':\n    case 'COM':\n    case 'COMM':\n      var out = {}\n\n      offset += 1\n\n      out.language = decodeString(b.slice(offset, offset + 3), 'iso-8859-1')\n      offset += 3\n\n      fzero = findZero(b, offset, length, encoding)\n      out.description = decodeString(b.slice(offset, fzero), encoding)\n      offset = fzero + nullTerminatorLength\n\n      out.text = decodeString(b.slice(offset, length), encoding).replace(/\\x00+$/, '')\n\n      output = [out]\n      break\n\n    case 'UFID':\n      var ufid = {}\n\n      fzero = findZero(b, offset, length, encoding)\n      ufid.owner_identifier = decodeString(b.slice(offset, fzero), encoding)\n      offset = fzero + nullTerminatorLength\n\n      ufid.identifier = b.slice(offset, length)\n      output = [ufid]\n      break\n  }\n\n  return output\n}\n\nfunction getTextEncoding (byte) {\n  switch (byte) {\n    case 0x00:\n      return 'iso-8859-1' // binary\n    case 0x01:\n    case 0x02:\n      return 'utf16' // 01 = with bom, 02 = without bom\n    case 0x03:\n      return 'utf8'\n    default:\n      return 'utf8'\n  }\n}\n\nfunction getNullTerminatorLength (enc) {\n  switch (enc) {\n    case 'utf16':\n      return 2\n    default:\n      return 1\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/node_modules/musicmetadata/lib/id4.js":"'use strict'\nvar strtok = require('strtok2')\nvar common = require('./common')\n\nmodule.exports = function (stream, callback, done, readDuration) {\n  strtok.parse(stream, function (v, cb) {\n    // the very first thing we expect to see is the first atom's length\n    if (!v) {\n      cb.metaAtomsTotalLength = 0\n      cb.state = 0\n      return strtok.UINT32_BE\n    }\n\n    switch (cb.state) {\n      case -1: // skip\n        cb.state = 0\n        return strtok.UINT32_BE\n\n      case 0: // atom length\n        cb.atomLength = v\n        cb.state++\n        return new strtok.BufferType(4)\n\n      case 1: // atom name\n        v = v.toString('binary')\n        cb.atomName = v\n\n        // meta has 4 bytes padding at the start (skip)\n        if (v === 'meta') {\n          cb.state = -1\n          return new strtok.IgnoreType(4)\n        }\n\n        if (readDuration) {\n          if (v === 'mdhd') {\n            cb.state = 3\n            return new strtok.BufferType(cb.atomLength - 8)\n          }\n        }\n\n        if (!~CONTAINER_ATOMS.indexOf(v)) {\n          if (cb.atomContainer === 'ilst') {\n            cb.state = 2\n            return new strtok.BufferType(cb.atomLength - 8)\n          }\n          cb.state = -1\n          return new strtok.IgnoreType(cb.atomLength - 8)\n        }\n\n        // dig into container atoms\n        cb.atomContainer = v\n        cb.atomContainerLength = cb.atomLength\n        cb.state--\n        return strtok.UINT32_BE\n\n      case 2: // ilst atom\n        cb.metaAtomsTotalLength += cb.atomLength\n        var result = processMetaAtom(v, cb.atomName, cb.atomLength - 8)\n        if (result.length > 0) {\n          for (var i = 0; i < result.length; i++) {\n            callback(cb.atomName, result[i])\n          }\n        }\n\n        // we can stop processing atoms once we get to the end of the ilst atom\n        if (cb.metaAtomsTotalLength >= cb.atomContainerLength - 8) {\n          return done()\n        }\n\n        cb.state = 0\n        return strtok.UINT32_BE\n\n      case 3: // mdhd atom\n        // TODO: support version 1\n        var sampleRate = v.readUInt32BE(12)\n        var duration = v.readUInt32BE(16)\n        callback('duration', duration / sampleRate)\n        cb.state = 0\n        return strtok.UINT32_BE\n    }\n\n    // if we ever get this this point something bad has happened\n    return done(new Error('error parsing'))\n  })\n}\n\nfunction processMetaAtom (data, atomName, atomLength) {\n  var result = []\n  var offset = 0\n\n  // ignore proprietary iTunes atoms (for now)\n  if (atomName === '----') return result\n\n  while (offset < atomLength) {\n    var length = strtok.UINT32_BE.get(data, offset)\n    var type = TYPES[strtok.UINT32_BE.get(data, offset + 8)]\n\n    var content = processMetaDataAtom(data.slice(offset + 12, offset + length), type, atomName)\n\n    result.push(content)\n    offset += length\n  }\n\n  return result\n\n  function processMetaDataAtom (data, type, atomName) {\n    switch (type) {\n      case 'text':\n        return data.toString('utf8', 4)\n\n      case 'uint8':\n        if (atomName === 'gnre') {\n          var genreInt = strtok.UINT8.get(data, 5)\n          return common.GENRES[genreInt - 1]\n        }\n        if (atomName === 'trkn' || atomName === 'disk') {\n          return data[7] + '/' + data[9]\n        }\n\n        return strtok.UINT8.get(data, 4)\n\n      case 'jpeg':\n      case 'png':\n        return {\n          format: 'image/' + type,\n          data: new Buffer(data.slice(4))\n        }\n    }\n  }\n}\n\nvar TYPES = {\n  '0': 'uint8',\n  '1': 'text',\n  '13': 'jpeg',\n  '14': 'png',\n  '21': 'uint8'\n}\n\nvar CONTAINER_ATOMS = ['moov', 'udta', 'meta', 'ilst', 'trak', 'mdia']\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/node_modules/musicmetadata/lib/ogg.js":"'use strict'\nvar events = require('events')\nvar strtok = require('strtok2')\nvar common = require('./common')\nvar sum = common.sum\n\nmodule.exports = function (stream, callback, done, readDuration) {\n  var innerStream = new events.EventEmitter()\n\n  var pageLength = 0\n  var sampleRate = 0\n  var header\n  var stop = false\n\n  stream.on('end', function () {\n    if (readDuration) {\n      callback('duration', header.pcm_sample_pos / sampleRate)\n      done()\n    }\n  })\n\n  // top level parser that handles the parsing of pages\n  strtok.parse(stream, function (v, cb) {\n    if (!v) {\n      cb.state = 0\n      return new strtok.BufferType(27)\n    }\n\n    if (stop) {\n      return done()\n    }\n\n    switch (cb.state) {\n      case 0: // header\n        header = {\n          type: v.toString('ascii', 0, 4),\n          version: v[4],\n          packet_flag: v[5],\n          pcm_sample_pos: (v.readUInt32LE(10) << 32) + v.readUInt32LE(6),\n          stream_serial_num: strtok.UINT32_LE.get(v, 14),\n          page_number: strtok.UINT32_LE.get(v, 18),\n          check_sum: strtok.UINT32_LE.get(v, 22),\n          segments: v[26]\n        }\n        if (header.type !== 'OggS') {\n          return done(new Error('expected ogg header but was not found'))\n        }\n        cb.pageNumber = header.page_number\n        cb.state++\n        return new strtok.BufferType(header.segments)\n\n      case 1: // segments\n        pageLength = sum(v)\n        cb.state++\n        return new strtok.BufferType(pageLength)\n\n      case 2: // page data\n        innerStream.emit('data', new Buffer(v))\n        cb.state = 0\n        return new strtok.BufferType(27)\n    }\n  })\n\n  // Second level parser that handles the parsing of metadata.\n  // The top level parser emits data that this parser should\n  // handle.\n  strtok.parse(innerStream, function (v, cb) {\n    if (!v) {\n      cb.commentsRead = 0\n      cb.state = 0\n      return new strtok.BufferType(7)\n    }\n\n    switch (cb.state) {\n      case 0: // type\n        if (v.toString() === '\\x01vorbis') {\n          cb.state = 6\n          return new strtok.BufferType(23)\n        } else if (v.toString() === '\\x03vorbis') {\n          cb.state++\n          return strtok.UINT32_LE\n        } else {\n          return done(new Error('expected vorbis header but found something else'))\n        }\n      break\n\n      case 1: // vendor length\n        cb.state++\n        return new strtok.BufferType(v)\n\n      case 2: // vendor string\n        cb.state++\n        return new strtok.BufferType(4)\n\n      case 3: // user comment list length\n        cb.commentsLength = v.readUInt32LE(0)\n        // no metadata, stop parsing\n        if (cb.commentsLength === 0) return strtok.DONE\n        cb.state++\n        return strtok.UINT32_LE\n\n      case 4: // comment length\n        cb.state++\n        return new strtok.BufferType(v)\n\n      case 5: // comment\n        cb.commentsRead++\n        v = v.toString()\n        var idx = v.indexOf('=')\n        var key = v.slice(0, idx).toUpperCase()\n        var value = v.slice(idx + 1)\n\n        if (key === 'METADATA_BLOCK_PICTURE') {\n          value = common.readVorbisPicture(new Buffer(value, 'base64'))\n        }\n\n        callback(key, value)\n\n        if (cb.commentsRead === cb.commentsLength) {\n          // if we don't want to read the duration\n          // then tell the parent stream to stop\n          stop = !readDuration\n          return strtok.DONE\n        }\n\n        cb.state-- // back to comment length\n        return strtok.UINT32_LE\n\n      case 6: // vorbis info\n        var info = {\n          'version': v.readUInt32LE(0),\n          'channel_mode': v.readUInt8(4),\n          'sample_rate': v.readUInt32LE(5),\n          'bitrate_nominal': v.readUInt32LE(13)\n        }\n        sampleRate = info.sample_rate\n        cb.state = 0\n        return new strtok.BufferType(7)\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/node_modules/musicmetadata/lib/flac.js":"'use strict'\nvar strtok = require('strtok2')\nvar common = require('./common')\n\nmodule.exports = function (stream, callback, done) {\n  var currentState = startState\n\n  strtok.parse(stream, function (v, cb) {\n    currentState = currentState.parse(callback, v, done)\n    return currentState.getExpectedType()\n  })\n}\n\nvar DataDecoder = function (data) {\n  this.data = data\n  this.offset = 0\n}\n\nDataDecoder.prototype.readInt32 = function () {\n  var value = strtok.UINT32_LE.get(this.data, this.offset)\n  this.offset += 4\n  return value\n}\n\nDataDecoder.prototype.readStringUtf8 = function () {\n  var len = this.readInt32()\n  var value = this.data.toString('utf8', this.offset, this.offset + len)\n  this.offset += len\n  return value\n}\n\nvar finishedState = {\n  parse: function (callback) {\n    return this\n  },\n  getExpectedType: function () {\n    return strtok.DONE\n  }\n}\n\nvar BlockDataState = function (type, length, nextStateFactory) {\n  this.type = type\n  this.length = length\n  this.nextStateFactory = nextStateFactory\n}\n\nBlockDataState.prototype.parse = function (callback, data) {\n  if (this.type === 4) {\n    var decoder = new DataDecoder(data)\n    decoder.readStringUtf8() // vendor (skip)\n    var commentListLength = decoder.readInt32()\n    var comment\n    var split\n    var i\n\n    for (i = 0; i < commentListLength; i++) {\n      comment = decoder.readStringUtf8()\n      split = comment.split('=')\n      callback(split[0].toUpperCase(), split[1])\n    }\n  } else if (this.type === 6) {\n    var picture = common.readVorbisPicture(data)\n    callback('METADATA_BLOCK_PICTURE', picture)\n  } else if (this.type === 0) { // METADATA_BLOCK_STREAMINFO\n    if (data.length < 34) return // invalid streaminfo\n    var sampleRate = common.strtokUINT24_BE.get(data, 10) >> 4\n    var totalSamples = data.readUInt32BE(14)\n    var duration = totalSamples / sampleRate\n    callback('duration', duration)\n  }\n\n  return this.nextStateFactory()\n}\n\nBlockDataState.prototype.getExpectedType = function () {\n  return new strtok.BufferType(this.length)\n}\n\nvar blockHeaderState = {\n  parse: function (callback, data, done) {\n    var header = {\n      lastBlock: (data[0] & 0x80) === 0x80,\n      type: data[0] & 0x7f,\n      length: common.strtokUINT24_BE.get(data, 1)\n    }\n    var followingStateFactory = header.lastBlock ? function () {\n      done()\n      return finishedState\n    } : function () {\n      return blockHeaderState\n    }\n\n    return new BlockDataState(header.type, header.length, followingStateFactory)\n  },\n  getExpectedType: function () {\n    return new strtok.BufferType(4)\n  }\n}\n\nvar idState = {\n  parse: function (callback, data, done) {\n    if (data.toString() !== 'fLaC') {\n      done(new Error('expected flac header but was not found'))\n    }\n    return blockHeaderState\n  },\n  getExpectedType: function () {\n    return new strtok.BufferType(4)\n  }\n}\n\nvar startState = {\n  parse: function (callback) {\n    return idState\n  },\n  getExpectedType: function () {\n    return strtok.DONE\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-musicmetadata/node_modules/musicmetadata/lib/monkeysaudio.js":"'use strict'\nvar common = require('./common')\nvar strtok = require('strtok2')\n\nmodule.exports = function (stream, callback, done) {\n  var ApeDescriptor = {\n    len: 44,\n\n    get: function (buf, off) {\n      return {\n        ID: new strtok.StringType(4, 'ascii').get(buf, off),\n        version: strtok.UINT32_LE.get(buf, off + 4) / 1000,\n        descriptorBytes: strtok.UINT32_LE.get(buf, off + 8),\n        headerDataBytes: strtok.UINT32_LE.get(buf, off + 12),\n        APEFrameDataBytes: strtok.UINT32_LE.get(buf, off + 16),\n        APEFrameDataBytesHigh: strtok.UINT32_LE.get(buf, off + 20),\n        terminatingDataBytes: strtok.UINT32_LE.get(buf, off + 24),\n        fileMD5: new strtok.BufferType(16).get(buf, 28)\n      }\n    }\n  }\n\n  // headerDataBytes = 24\n\n  var ApeHeader = {\n    len: 24,\n\n    get: function (buf, off) {\n      return {\n        compressionLevel: strtok.UINT16_LE.get(buf, off),\n        formatFlags: strtok.UINT16_LE.get(buf, off + 2),\n        blocksPerFrame: strtok.UINT32_LE.get(buf, off + 4),\n        finalFrameBlocks: strtok.UINT32_LE.get(buf, off + 8),\n        totalFrames: strtok.UINT32_LE.get(buf, off + 12),\n        bitsPerSample: strtok.UINT16_LE.get(buf, off + 16),\n        channel: strtok.UINT16_LE.get(buf, off + 18),\n        sampleRate: strtok.UINT32_LE.get(buf, off + 20)\n      }\n    }\n  }\n\n  strtok.parse(stream, function (v, cb) {\n    if (v === undefined) {\n      cb.state = 0\n      return ApeDescriptor\n    }\n\n    switch (cb.state) {\n      case 0:\n        if (v.ID !== 'MAC ') {\n          throw new Error('Expected MAC on beginning of file')\n        }\n        cb.state = 1\n        return new strtok.BufferType(v.descriptorBytes - 44)\n\n      case 1:\n        cb.state = 2\n        return ApeHeader\n\n      case 2:\n        callback('duration', calculateDuration(v))\n        return -1\n    }\n  })\n\n  return readMetadata(stream, callback, done)\n}\n\n/**\n * Calculate the media file duration\n * @param ah ApeHeader\n * @return {number} duration in seconds\n */\nfunction calculateDuration (ah) {\n  var duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0\n  duration += ah.finalFrameBlocks\n  return duration / ah.sampleRate\n}\n\nfunction readMetadata (stream, callback, done) {\n  var bufs = []\n\n  // TODO: need to be able to parse the tag if its at the start of the file\n  stream.on('data', function (data) {\n    bufs.push(data)\n  })\n\n  common.streamOnRealEnd(stream, function () {\n    var buffer = Buffer.concat(bufs)\n    var offset = buffer.length - 32\n\n    if (buffer.toString('utf8', offset, offset += 8) !== 'APETAGEX') {\n      done(new Error(\"expected APE header but wasn't found\"))\n    }\n\n    var footer = {\n      version: strtok.UINT32_LE.get(buffer, offset, offset + 4),\n      size: strtok.UINT32_LE.get(buffer, offset + 4, offset + 8),\n      count: strtok.UINT32_LE.get(buffer, offset + 8, offset + 12)\n    }\n\n    // go 'back' to where the 'tags' start\n    offset = buffer.length - footer.size\n\n    for (var i = 0; i < footer.count; i++) {\n      var size = strtok.UINT32_LE.get(buffer, offset, offset += 4)\n      var flags = strtok.UINT32_LE.get(buffer, offset, offset += 4)\n      var kind = (flags & 6) >> 1\n\n      var zero = common.findZero(buffer, offset, buffer.length)\n      var key = buffer.toString('ascii', offset, zero)\n      offset = zero + 1\n\n      if (kind === 0) { // utf-8 textstring\n        var value = buffer.toString('utf8', offset, offset += size)\n        var values = value.split(/\\x00/g)\n\n        /*jshint loopfunc:true */\n        values.forEach(function (val) {\n          callback(key, val)\n        })\n      } else if (kind === 1) { // binary (probably artwork)\n        if (key === 'Cover Art (Front)' || key === 'Cover Art (Back)') {\n          var picData = buffer.slice(offset, offset + size)\n\n          var off = 0\n          zero = common.findZero(picData, off, picData.length)\n          var description = picData.toString('utf8', off, zero)\n          off = zero + 1\n\n          var picture = {\n            description: description,\n            data: new Buffer(picData.slice(off))\n          }\n\n          offset += size\n          callback(key, picture)\n        }\n      }\n    }\n    return done()\n  })\n}\n"}